<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhaseSentinel - Cyberpunk Profiler</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Cyberpunk theme */
        :root {
            --bg-dark: #0c1c33;
            --primary: #64ffda;
            --warning: #ffb86c;
            --critical: #ff5555;
            --accent: #bd93f9;
            --text: #f8f8f2;
            --text-secondary: #cdd3de;
            --card-bg: rgba(25, 33, 48, 0.8);
            --border-color: #64ffda;
            --glow-primary: 0 0 10px rgba(100, 255, 218, 0.5);
            --glow-warning: 0 0 10px rgba(255, 184, 108, 0.5);
            --glow-critical: 0 0 10px rgba(255, 85, 85, 0.5);
            --glow-accent: 0 0 10px rgba(189, 147, 249, 0.5);
        }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text);
            font-family: 'Fira Code', 'JetBrains Mono', monospace;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-image: radial-gradient(rgba(100, 255, 218, 0.05) 1px, transparent 1px),
                              radial-gradient(rgba(189, 147, 249, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            background-position: 0 0, 25px 25px;
        }
        
        .cyber-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Top bar controls */
        .top-controls {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.2);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .control-group input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            flex: 1;
            min-width: 300px;
        }
        
        .btn {
            background: var(--primary);
            color: var(--bg-dark);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            box-shadow: var(--glow-primary);
        }
        
        .btn-stop {
            background: var(--critical);
        }
        
        .btn-stop:hover {
            box-shadow: var(--glow-critical);
        }
        
        .status-indicator {
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .status-idle {
            background: #333;
            color: #aaa;
        }
        
        .status-running {
            background: var(--primary);
            color: var(--bg-dark);
            animation: pulse 1.5s infinite;
        }
        
        .status-error {
            background: var(--critical);
            color: white;
            animation: pulse 0.5s infinite;
        }
        
        /* Help Text */
        .help-text {
            margin-top: 10px;
            font-size: 0.8rem;
            color: var(--accent);
            text-align: center;
        }
        
        .help-text small {
            font-family: 'Fira Code', monospace;
            color: var(--primary);
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* Tab navigation */
        .tabs {
            display: flex;
            border-bottom: 2px solid var(--accent);
            margin-bottom: 20px;
        }
        
        .tab {
            background: transparent;
            border: none;
            color: var(--text);
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Fira Code', monospace;
            font-size: 16px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }
        
        .tab:hover:not(.active) {
            color: var(--accent);
        }
        
        /* Tab content */
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Card styles */
        .card {
            background: var(--card-bg);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        
        .card h2 {
            color: var(--accent);
            margin-top: 0;
            border-bottom: 1px solid var(--accent);
            padding-bottom: 10px;
        }
        
        /* System Context Card - visually de-emphasized */
        .system-context {
            background: rgba(15, 25, 40, 0.6); /* More de-emphasized */
            border: 1px dashed var(--accent);
            opacity: 0.8;
        }
        
        /* System Context h2 no longer uses ::after pseudo-element */
        
        /* Metric cards */
        .metric-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--primary);
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            margin: 5px 0;
        }
        
        /* Reduce Programme Name font size */
        #prog-name {
            font-size: 14px;
        }
        
        .metric-label {
            font-size: 14px;
            color: var(--accent);
        }
        
        /* Phase badge */
        .phase-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 12px;
            background: var(--primary);
            color: var(--bg-dark);
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px currentColor; }
            to { box-shadow: 0 0 20px currentColor; }
        }
        
        /* Charts */
        .chart-container {
            height: 300px;
            margin: 20px 0;
        }
        
        canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Alerts */
        .alert {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid;
        }
        
        .alert-warning {
            background: rgba(255, 184, 108, 0.1);
            border-color: var(--warning);
            color: var(--warning);
        }
        
        .alert-critical {
            background: rgba(255, 85, 85, 0.1);
            border-color: var(--critical);
            color: var(--critical);
        }
        
        .alert-info {
            background: rgba(100, 255, 218, 0.1);
            border-color: var(--primary);
            color: var(--primary);
        }
        
        /* Glow effect for alerts */
        .glow {
            animation: glow 2s infinite alternate;
        }
        
        /* Tree view */
        .tree-view {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--accent);
        }
        
        /* Phase timeline */
        .phase-timeline {
            height: 100px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border: 1px solid var(--accent);
        }
        
        /* Deadlock graph */
        .deadlock-graph {
            height: 400px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border: 1px solid var(--accent);
        }
        
        /* Process table */
        .process-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .process-table th, .process-table td {
            border: 1px solid var(--accent);
            padding: 8px;
            text-align: left;
        }
        
        .process-table th {
            background: rgba(100, 255, 218, 0.1);
            color: var(--primary);
        }
        
        /* Insight panel */
        .insight-panel {
            background: rgba(189, 147, 249, 0.1);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        
        /* Optimization card */
        .optimization-card {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid var(--primary);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <nav class="navbar" style="background: var(--bg-dark); border-bottom: 1px solid var(--primary);">
        <div class="nav-content">
            <div class="logo">⚡ PhaseSentinel</div>
            <ul class="nav-links">
                <li><a href="/dashboard" class="active" style="color: var(--primary);">Dashboard</a></li>
            </ul>
        </div>
    </nav>

    <div class="cyber-container">
        <!-- Top Controls for Profiling -->
        <div class="top-controls">
            <div class="control-group">
                <input type="text" id="programPath" placeholder="Enter program file path (e.g., ../backend/simulations/leaky.py)">
                <input type="number" id="profilingDuration" placeholder="Duration (seconds)" min="1" max="300" value="60" style="width: 120px;">
                <button id="startProfiling" class="btn">Start Profiling</button>
                <button id="stopProfiling" class="btn btn-stop" style="margin-left: 10px;">⏹ STOP</button>
                <div class="status-indicator status-idle" id="statusIndicator">Idle</div>
                <div id="countdownTimer" style="margin-left: 15px; color: var(--primary); font-size: 16px; font-weight: bold; display: none; background: rgba(100, 255, 218, 0.1); padding: 8px 15px; border-radius: 4px; border: 1px solid var(--primary);">⏱ 00:60</div>
                <div id="programInfo" style="margin-left: 10px; color: var(--accent); font-size: 14px;"></div>
            </div>
            <div class="help-text">
                <small>Try: ../backend/simulations/leaky.py | ../backend/simulations/fork_bomb.py | ../backend/simulations/miner_sim.py | Duration: 1-300 seconds</small>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="overview">Programme Matrix</button>
            <button class="tab" data-tab="execution">Execution & Concurrency Analysis</button>
            <button class="tab" data-tab="intelligence">Intelligence & Optimization</button>
        </div>

        <!-- Tab Content -->
        <div id="overviewTab" class="tab-content active">
            <!-- Program-Scoped Metrics -->
            <div class="card">
                <h2>Program Metrics</h2>
                <div class="metric-cards">
                    <div class="metric-card">
                        <div class="metric-label">Program Name</div>
                        <div class="metric-value" id="prog-name" style="font-size: 12px; font-weight: 600;">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">PID</div>
                        <div class="metric-value" id="prog-pid">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Uptime</div>
                        <div class="metric-value" id="prog-uptime">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Current Phase</div>
                        <div class="metric-value"><span class="phase-badge" id="current-phase">--</span></div>
                    </div>

                    <div class="metric-card">
                        <div class="metric-label">Anomaly Score</div>
                        <div class="metric-value" id="anomaly-score">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Deadlock Status</div>
                        <div class="metric-value" id="deadlock-status">--</div>
                    </div>
                    
                </div>
                
                <!-- Live Uptime Indicator -->
                <div style="text-align: center; margin-top: 20px;">
                    <div style="font-size: 18px; color: var(--primary);">Live Uptime: <span id="live-uptime">00:00:00</span></div>
                </div>
            </div>

            <!-- Program-Scoped CPU/Memory/Disk Charts -->
            <div class="card">
                <h2>System Resource Usage</h2>
                <div class="chart-container">
                    <canvas id="programResourceChart"></canvas>
                </div>
            </div>

            <!-- System Context (clearly labeled and de-emphasized) -->
            <div class="card system-context">
                <h2>System-Wide Context</h2>
                <div class="metric-cards">
                    <div class="metric-card">
                        <div class="metric-label">Total CPU % (System-wide)</div>
                        <div class="metric-value" id="sys-cpu">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Memory % (System-wide)</div>
                        <div class="metric-value" id="sys-mem">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Disk I/O Rate (System-wide)</div>
                        <div class="metric-value" id="sys-disk-io">--</div>
                    </div>
                </div>
                
                <!-- Phase Distribution and Top Consumers -->
                <div class="metric-cards">
                    <div class="metric-card">
                        <div class="metric-label">Phase Distribution (Top System)</div>
                        <div class="metric-value" id="sys-phase-dist">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Top System Consumers</div>
                        <div class="metric-value" id="top-sys-consumers">--</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="executionTab" class="tab-content">
            <!-- Process Table -->
            <div class="card">
                <h2>Process Analysis (Process-Specific Values)</h2>
                <table class="process-table">
                    <thead>
                        <tr>
                            <th>PID</th>
                            <th>Name</th>
                            <th>CPU %</th>
                            <th>Memory %</th>
                            <th>Memory (MB)</th>
                            <th>Threads</th>
                            <th>Phase</th>
                        </tr>
                    </thead>
                    <tbody id="processTableBody">
                        <tr><td colspan="8">Loading processes...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Live Charts -->
            <div class="card">
                <h2>Live Metrics (Last 60s)</h2>
                <div class="chart-container">
                    <canvas id="liveMetricsChart"></canvas>
                </div>
            </div>

            <!-- Phase Analysis -->
            <div class="card">
                <h2>Phase Analysis</h2>
                <div class="insight-panel">
                    <h3>Gantt-style Timeline</h3>
                    <div class="phase-timeline" id="phaseTimeline"></div>
                </div>
                
                <div class="insight-panel">
                    <h3>Phase Distribution</h3>
                    <div class="chart-container">
                        <canvas id="phaseDistributionChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Deadlock Analysis -->
            <div class="card">
                <h2>Deadlock Analysis</h2>
                
                <div class="insight-panel">
                    <h3>System Safety Status</h3>
                    <div id="deadlockStatus" class="alert alert-info">Analyzing...</div>
                </div>
                
                <div class="insight-panel">
                    <h3>Deadlock Alerts</h3>
                    <div id="deadlockAlerts" class="alert-container">
                        <p>Monitoring for deadlock risks...</p>
                    </div>
                </div>
                
                <div class="insight-panel" id="waitForGraphContainer" style="display: none;">
                    <h3>Wait-for Graph (Only shown when deadlock detected)</h3>
                    <div class="deadlock-graph" id="deadlockGraph"></div>
                </div>
                
                <div class="insight-panel">
                    <h3>Suggested Actions</h3>
                    <div id="deadlockFixes">No issues detected</div>
                </div>
            </div>

        </div>

        <div id="intelligenceTab" class="tab-content">
            <!-- Anomaly Visualization -->
            <div class="card">
                <h2>Anomaly Score Time-series</h2>
                <div class="chart-container">
                    <canvas id="anomalyTimelineChart"></canvas>
                </div>
            </div>

            <!-- Threat Classification -->
            <div class="card">
                <h2>Threat Classification</h2>
                <div id="threatClassification">
                    <div class="alert alert-info">Scanning for threats...</div>
                </div>
            </div>




        </div>
    </div>

    <script>
        // Global variables
        let currentPid = null;
        let wsConnection = null;
        let programResourceChart = null;
        let liveMetricsChart = null;
        let phaseDistributionChart = null;
        let anomalyTimelineChart = null;
        let uptimeInterval = null;
        let profile_data = {};

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and content
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab
                tab.classList.add('active');
                
                // Show corresponding content
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(`${tabName}Tab`).classList.add('active');
                
                // Refresh the active tab's content
                if (currentPid) {
                    updateTabContent(tabName);
                }
            });
        });
        
        // Start uptime counter
        function startUptimeCounter() {
            if (uptimeInterval) clearInterval(uptimeInterval);
            
            uptimeInterval = setInterval(() => {
                if (document.getElementById('prog-uptime').textContent !== '--') {
                    // Parse the current uptime and increment
                    const uptimeText = document.getElementById('prog-uptime').textContent;
                    const parts = uptimeText.split(':').map(Number);
                    let seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
                    seconds++;
                    
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const secs = seconds % 60;
                    
                    document.getElementById('live-uptime').textContent = 
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        // Stop uptime counter
        function stopUptimeCounter() {
            if (uptimeInterval) {
                clearInterval(uptimeInterval);
                uptimeInterval = null;
            }
            document.getElementById('live-uptime').textContent = '00:00:00';
        }

        // Timer variables
        let profilingTimer = null;
        let startTime = null;
        let profilingDurationSec = 0;
        
        // Format time as MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update timer display with countdown
        function updateTimer() {
            if (!startTime || !profilingDurationSec) return;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const remaining = Math.max(0, profilingDurationSec - elapsed);
            
            const countdownDisplay = document.getElementById('countdownTimer');
            const mins = Math.floor(remaining / 60);
            const secs = remaining % 60;
            countdownDisplay.textContent = `⏱ ${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            countdownDisplay.style.display = 'inline-block';
            
            if (remaining <= 0) {
                clearInterval(profilingTimer);
                countdownDisplay.style.display = 'none';
                // Profiling duration reached; trigger post-profiling updates
                onProfilingDurationComplete();
            }
        }
        
        // Start profiling handler
        document.getElementById('startProfiling').addEventListener('click', async () => {
            const programPath = document.getElementById('programPath').value.trim();
            const duration = parseInt(document.getElementById('profilingDuration').value) || 60;
            
            if (!programPath) {
                alert('Please enter a program file path');
                return;
            }
            
            if (duration < 1 || duration > 300) {
                alert('Please enter a duration between 1 and 300 seconds');
                return;
            }
            
            // Update status
            const statusEl = document.getElementById('statusIndicator');
            statusEl.className = 'status-indicator status-running';
            statusEl.textContent = `Running (${duration}s)`;
            
            // Show stop button
            document.getElementById('stopProfiling').style.display = 'inline-block';
            
            // Start timer
            startTime = Date.now();
            profilingDurationSec = duration;
            
            if (profilingTimer) {
                clearInterval(profilingTimer);
            }
            profilingTimer = setInterval(updateTimer, 1000);
            
            try {
                const response = await fetch('/api/profile/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        file_path: programPath,
                        duration: duration
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentPid = data.pid;
                    document.getElementById('programInfo').textContent = `PID: ${currentPid}`;
                    
                    // Start real-time updates
                    startRealTimeUpdates();
                    
                    // Update program metrics
                    updateDashboard();
                    
                    // Immediately update execution tab to show process data
                    if (document.querySelector('.tab.active').getAttribute('data-tab') === 'execution') {
                        updateExecutionTab();
                    }
                    
                    startUptimeCounter();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                statusEl.className = 'status-indicator status-error';
                statusEl.textContent = 'Error';
                alert(`Error starting profiling: ${error.message}`);
            }
        });
        
        // Stop profiling handler
        const stopBtn = document.getElementById('stopProfiling');
        if (stopBtn) {
            stopBtn.addEventListener('click', async () => {
                // Hide stop button
                stopBtn.style.display = 'none';
                
                // Stop the countdown timer
                if (profilingTimer) {
                    clearInterval(profilingTimer);
                    profilingTimer = null;
                }
                
                // Hide countdown timer
                const countdownDisplay = document.getElementById('countdownTimer');
                if (countdownDisplay) {
                    countdownDisplay.style.display = 'none';
                }
                
                if (currentPid) {
                    try {
                        // Call stop API
                        await fetch('/api/profile/stop', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ pid: currentPid })
                        });
                        
                        // Update status
                        const statusEl = document.getElementById('statusIndicator');
                        statusEl.className = 'status-indicator status-idle';
                        statusEl.textContent = 'Stopped';
                        
                        // Finalize all analyses by updating the dashboard
                        // Wait a moment for the server to finalize data
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Fetch final data and update all displays
                        await updateDashboard();
                        
                        // Update all analysis sections with final data
                        const profileResponse = await fetch(`/api/profile?pid=${currentPid}`);
                        if (profileResponse.ok) {
                            const data = await profileResponse.json();
                            
                            // Update threat classification if available
                            if (data.threat_classification) {
                                updateThreatClassification(data.threat_classification);
                            }
                        }
                        
                        // Force update of execution tab to ensure Gantt-style timeline is shown
                        await updateExecutionTab();
                    } catch (e) { 
                        console.error('Error stopping profiling:', e);
                    }
                }
            });
        }
        
        // Clear metrics when profiling stops
        function clearMetrics() {
            // Reset program metrics
            document.getElementById('prog-name').textContent = '--';
            document.getElementById('prog-pid').textContent = '--';
            document.getElementById('prog-uptime').textContent = '--';
            document.getElementById('current-phase').textContent = '--';
            document.getElementById('anomaly-score').textContent = '--';
            document.getElementById('deadlock-status').textContent = '--';
            document.getElementById('anomaly-risk').textContent = '--';
            
            // Reset system metrics
            document.getElementById('sys-cpu').textContent = '--';
            document.getElementById('sys-mem').textContent = '--';
            document.getElementById('sys-disk-io').textContent = '--';
            document.getElementById('sys-phase-dist').textContent = '--';
            document.getElementById('top-sys-consumers').textContent = '--';
            
            // Clear charts
            if (programResourceChart) {
                programResourceChart.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                programResourceChart.update();
            }
        }
        
        // Start real-time updates via WebSocket
        function startRealTimeUpdates() {
            // In a real implementation, this would connect to WebSocket
            // For now, we'll simulate with polling
            setInterval(updateDashboard, 1000);
        }
        
        // Update dashboard with latest data
        async function updateDashboard() {
            if (!currentPid) return;
            
            try {
                // Get profile data
                const profileResponse = await fetch(`/api/profile?pid=${currentPid}`);
                if (profileResponse.ok) {
                    const profileData = await profileResponse.json();
                    updateProgramMetrics(profileData);
                }
                
                // Get metrics data separately to update profile_data
                const metricsResponse = await fetch(`/api/profile/${currentPid}/metrics?duration=60`);
                if (metricsResponse.ok) {
                    const metricsData = await metricsResponse.json();
                    if (metricsData.metrics && Array.isArray(metricsData.metrics)) {
                        if (!profile_data[currentPid]) {
                            profile_data[currentPid] = [];
                        }
                        // Update profile_data with current metrics
                        profile_data[currentPid] = [...metricsData.metrics];
                    }
                }
                
                // Get system data
                const systemResponse = await fetch('/api/system');
                if (systemResponse.ok) {
                    const systemData = await systemResponse.json();
                    updateSystemMetrics(systemData);
                }
                
                // Update charts
                updateRealtimeCharts();
                
                // Update live metrics chart with process-specific data
                updateLiveMetricsChart();
                
                // Update active tab content
                const activeTab = document.querySelector('.tab.active').getAttribute('data-tab');
                updateTabContent(activeTab);
            } catch (error) {
                console.error('Error updating dashboard:', error);
            }
        }
        
        // Update specific tab content
        function updateTabContent(tabName) {
            switch(tabName) {
                case 'overview':
                    updateOverviewTab();
                    break;
                case 'execution':
                    updateExecutionTab();
                    break;
                case 'intelligence':
                    updateIntelligenceTab();
                    break;
            }
        }
        
        // Update Overview tab
        function updateOverviewTab() {
            // Already handled by general update functions
        }
        
        // Update Execution tab
        async function updateExecutionTab() {
            if (!currentPid) return;
            
            try {
                // Get process tree
                const treeResponse = await fetch(`/api/profile/${currentPid}/tree`);
                if (treeResponse.ok) {
                    const treeData = await treeResponse.json();
                    updateProcessTable(treeData.process_tree);
                }
                
                // Get phases
                const phasesResponse = await fetch(`/api/profile/${currentPid}/phases`);
                if (phasesResponse.ok) {
                    const phasesData = await phasesResponse.json();
                    updatePhaseAnalysis(phasesData.phases);
                }
                
                // Get deadlock info
                const deadlockResponse = await fetch(`/api/profile/${currentPid}/deadlock`);
                if (deadlockResponse.ok) {
                    const deadlockData = await deadlockResponse.json();
                    updateDeadlockInfo(deadlockData);
                }
            } catch (error) {
                console.error('Error updating execution tab:', error);
            }
        }

        // Called when profiling duration reaches zero
        async function onProfilingDurationComplete() {
            if (!currentPid) return;

            // Poll profile status; once server reports profiling stopped, fetch final analyses
            try {
                const statusResp = await fetch(`/api/profile?pid=${currentPid}`);
                if (statusResp.ok) {
                    const status = await statusResp.json();
                    if (!status.is_running) {
                        // Final updates
                        updateDashboard();
                        await updateExecutionTab();
                        await updateIntelligenceTab();
                        // Fetch threat classification (anomaly model)
                        try {
                            const tresp = await fetch(`/api/profile/${currentPid}/threat`);
                            if (tresp.ok) {
                                const tdata = await tresp.json();
                                const tc = document.getElementById('threatClassification');
                                if (tdata.predicted && tdata.predicted === 'anomalous') {
                                    tc.innerHTML = `<div class="alert alert-critical"><strong>Predicted Anomaly:</strong> Anomalous</div>` + (tdata.alerts && tdata.alerts.length ? tdata.alerts.slice(0,3).map(a => `<div class="alert alert-warning">${a.message}</div>`).join('') : '');
                                } else {
                                    tc.innerHTML = `<div class="alert alert-info"><strong>Predicted:</strong> Normal</div>`;
                                }
                                // Update alert feed as well

                            }
                        } catch (e) { console.error('Error fetching threat classification:', e); }
                        
                        // Force update of phase analysis to show Gantt-style timeline
                        try {
                            const phasesResponse = await fetch(`/api/profile/${currentPid}/phases`);
                            if (phasesResponse.ok) {
                                const phasesData = await phasesResponse.json();
                                updatePhaseAnalysis(phasesData.phases);
                            }
                        } catch (e) { console.error('Error updating phase analysis:', e); }
                        
                        // Fetch and display deadlock analysis
                        try {
                            const deadlockResp = await fetch(`/api/profile/${currentPid}/deadlock`);
                            if (deadlockResp.ok) {
                                const deadlockData = await deadlockResp.json();
                                updateDeadlockInfo(deadlockData);
                            }
                        } catch (e) { console.error('Error fetching deadlock analysis:', e); }
                    } else {
                        // If still running, retry shortly
                        setTimeout(onProfilingDurationComplete, 1000);
                    }
                }
            } catch (e) {
                console.error('Error checking profile status:', e);
            }
        }

        // Update Intelligence tab
        async function updateIntelligenceTab() {
            if (!currentPid) return;
            
            try {
                // Get anomaly timeline
                const anomalyTimelineResponse = await fetch(`/api/profile/${currentPid}/anomaly/timeline`);
                if (anomalyTimelineResponse.ok) {
                    const anomalyData = await anomalyTimelineResponse.json();
                    updateAnomalyTimeline(anomalyData.anomalies);
                }
                
                // Get anomaly alerts
                const anomalyAlertsResponse = await fetch(`/api/profile/${currentPid}/anomaly/alerts`);
                if (anomalyAlertsResponse.ok) {
                    const alertData = await anomalyAlertsResponse.json();
                    updateThreatClassification(alertData.alerts);
                }
            } catch (error) {
                console.error('Error updating intelligence tab:', error);
            }
        }
        
        // Update program metrics display
        function updateProgramMetrics(data = {}) {
            document.getElementById('prog-name').textContent = data.program_path ? data.program_path.split('\\').pop().split('/').pop() : '--';
            document.getElementById('prog-pid').textContent = data.pid || '--';
            document.getElementById('prog-uptime').textContent = formatDuration(data.uptime || 0);

            document.getElementById('current-phase').textContent = data.current_phase || '--';
            document.getElementById('anomaly-score').textContent = (data.anomaly_score !== undefined) ? data.anomaly_score.toFixed(2) : (data.anomaly_count || 0);
            document.getElementById('deadlock-status').textContent = data.deadlock_detected ? 'DETECTED' : 'CLEAN';
        }
        
        // Format duration in seconds to HH:MM:SS
        function formatDuration(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update system metrics display
        function updateSystemMetrics(data = {}) {
            const sysMetrics = data.system_metrics || {};
            document.getElementById('sys-cpu').textContent = sysMetrics.cpu_percent ? `${sysMetrics.cpu_percent.toFixed(1)}%` : '--';
            document.getElementById('sys-mem').textContent = sysMetrics.memory_percent ? `${sysMetrics.memory_percent.toFixed(1)}%` : '--';
            document.getElementById('sys-disk-io').textContent = sysMetrics.disk_percent ? `${sysMetrics.disk_percent.toFixed(1)}%` : '--';
            
            const topProcs = (data.top_processes || []).slice(0, 3).map(p => p.name).join(', ');
            document.getElementById('top-sys-consumers').textContent = topProcs || '--';
        }
        
        // Update process table
        function updateProcessTable(processTree) {
            const tbody = document.getElementById('processTableBody');
            tbody.innerHTML = '';
            
            function addProcessRow(process, level = 0) {
                const tr = document.createElement('tr');
                
                // Apply indentation based on level
                const indent = '&nbsp;'.repeat(level * 4);
                
                tr.innerHTML = `
                    <td>${process.pid || '--'}</td>
                    <td>${indent}${process.name || 'Unknown Process'}</td>
                    <td>${process.cpu_percent !== undefined ? process.cpu_percent.toFixed(1) : '0.0'}%</td>
                    <td>${process.memory_percent !== undefined ? process.memory_percent.toFixed(1) : '0.0'}%</td>
                    <td>${process.memory_rss_mb !== undefined ? process.memory_rss_mb.toFixed(1) : '0.0'} MB</td>
                    <td>${process.num_threads || 0}</td>
                    <td><span class="phase-badge">${process.current_phase || 'unknown'}</span></td>
                `;
                
                // Make row clickable to select the process
                tr.onclick = function() {
                    // Remove previous selection
                    document.querySelectorAll('#processTableBody tr').forEach(row => {
                        row.style.backgroundColor = '';
                    });
                    
                    // Highlight selected row
                    tr.style.backgroundColor = 'rgba(100, 255, 218, 0.2)';
                    
                    // Update the main program metrics to show the selected process info
                    updateSelectedProcessMetrics(process);
                };
                
                tbody.appendChild(tr);
                
                // Add children
                (process.children || []).forEach(child => {
                    addProcessRow(child, level + 1);
                });
            }
            
            if (processTree && Object.keys(processTree).length > 0) {
                addProcessRow(processTree);
            } else {
                tbody.innerHTML = '<tr><td colspan="8"><div class="alert alert-info">No process data available. Process may have ended or is not accessible.</div></td></tr>';
            }
        }
        
        // Global variable to store selected process data for live metrics
        let selectedProcessData = null;
        
        // Update phase analysis (Gantt-style timeline only)
        function updatePhaseAnalysis(phases) {
            const timelineDiv = document.getElementById('phaseTimeline');
            
            if (phases && phases.length > 0) {
                // Update phase timeline visualization
                if (timelineDiv) {
                    timelineDiv.innerHTML = '';
                    const timelineContainer = document.createElement('div');
                    timelineContainer.style.display = 'flex';
                    timelineContainer.style.flexWrap = 'wrap';
                    timelineContainer.style.gap = '5px';
                    
                    phases.slice(-20).forEach((phase, index) => {
                        const phaseBlock = document.createElement('div');
                        phaseBlock.className = 'phase-badge';
                        phaseBlock.textContent = phase.phase.substring(0, 3).toUpperCase();
                        phaseBlock.title = `${phase.phase} (${new Date(phase.timestamp * 1000).toLocaleTimeString()})`;
                        phaseBlock.style.fontSize = '10px';
                        phaseBlock.style.padding = '2px 4px';
                        timelineContainer.appendChild(phaseBlock);
                    });
                    
                    timelineDiv.appendChild(timelineContainer);
                }
            } else {
                if (timelineDiv) {
                    timelineDiv.innerHTML = '<div class="alert alert-info">Phase timeline will appear here once data is collected</div>';
                }
            }
        }

        // Update deadlock info
        function updateDeadlockInfo(deadlockData) {
            const statusContainer = document.getElementById('deadlockStatus');
            const alertsContainer = document.getElementById('deadlockAlerts');
            const fixesContainer = document.getElementById('deadlockFixes');
            const graphContainer = document.getElementById('waitForGraphContainer');
            
            if (deadlockData && deadlockData.analysis) {
                const analysis = deadlockData.analysis;
                
                // Update system safety status
                if (analysis.has_cycles) {
                    statusContainer.innerHTML = `
                        <div class="alert alert-critical glow">
                            <strong>⚠ UNSAFE - DEADLOCK DETECTED!</strong><br>
                            ${analysis.cycle_count} cycle(s) found<br>
                            Risk Level: ${analysis.risk_level.toUpperCase()}<br>
                            ${analysis.nodes_in_cycles.length} nodes involved
                        </div>
                    `;
                    // Show wait-for graph only when deadlock is detected
                    if (graphContainer) {
                        graphContainer.style.display = 'block';
                        // Render the wait-for graph
                        if (deadlockData.graph) {
                            renderWaitForGraph(deadlockData.graph);
                        }
                    }
                } else {
                    statusContainer.innerHTML = `
                        <div class="alert alert-info">
                            <strong>✓ SAFE - No Deadlocks Detected</strong><br>
                            Risk Level: ${analysis.risk_level}<br>
                            ${analysis.total_locks_tracked} locks currently tracked
                        </div>
                    `;
                    // Hide wait-for graph when system is safe
                    if (graphContainer) {
                        graphContainer.style.display = 'none';
                    }
                }
                
                // Update alerts
                if (analysis.has_cycles) {
                    alertsContainer.innerHTML = `
                        <div class="alert alert-critical glow">
                            <strong>Cycle Detected!</strong><br>
                            Multiple wait-for cycle(s) detected in the system.<br>
                            Immediate action required to resolve deadlock condition.
                        </div>
                    `;
                } else {
                    alertsContainer.innerHTML = `
                        <div class="alert alert-info">
                            <strong>No Cycles Detected</strong><br>
                            System is operating normally with no circular dependencies.
                        </div>
                    `;
                }
                
                // Update suggested actions
                if (fixesContainer) {
                    if (analysis.has_cycles) {
                        fixesContainer.innerHTML = `
                            <div class="alert alert-warning">
                                <strong>Recommended Actions:</strong><br>
                                • Implement lock ordering protocol to prevent circular dependencies<br>
                                • Use timeout-based locks to detect and break potential cycles<br>
                                • Consider lock-free algorithms or data structures<br>
                                • Review and refactor thread synchronization patterns<br>
                                • Implement deadlock recovery mechanisms
                            </div>
                        `;
                    } else {
                        fixesContainer.innerHTML = `
                            <div class="alert alert-info">
                                <strong>Best Practices (Maintain):</strong><br>
                                • Continue maintaining consistent lock ordering<br>
                                • Use RAII pattern for automatic lock management<br>
                                • Monitor lock contention regularly<br>
                                • Consider async/await alternatives when possible
                            </div>
                        `;
                    }
                }
            } else {
                statusContainer.innerHTML = '<div class="alert alert-info">Analyzing system safety...</div>';
                alertsContainer.innerHTML = '<div class="alert alert-info">Analyzing for deadlock risks...</div>';
                if (fixesContainer) fixesContainer.innerHTML = '<div class="alert alert-info">Loading analysis...</div>';
                if (graphContainer) graphContainer.style.display = 'none';
            }
        }

        // Render wait-for graph using d3 (only displayed when deadlock detected)
        function renderWaitForGraph(graph) {
            const container = document.getElementById('deadlockGraph');
            if (!container) return;
            container.innerHTML = '';

            try {
                const width = container.clientWidth || 600;
                const height = container.clientHeight || 300;

                const svg = d3.select(container).append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const nodes = (graph.nodes || []).map(n => (typeof n === 'object' ? n : { id: n }));
                const links = (graph.edges || []).map(e => ({ source: e.source, target: e.target }));

                const simulation = d3.forceSimulation(nodes)
                    .force('charge', d3.forceManyBody().strength(-200))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                    .on('tick', ticked);

                const link = svg.append('g')
                    .attr('stroke', '#ff5555')
                    .selectAll('line')
                    .data(links)
                    .join('line')
                    .attr('stroke-width', 2);

                const node = svg.append('g')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1.5)
                    .selectAll('circle')
                    .data(nodes)
                    .join('circle')
                    .attr('r', 12)
                    .attr('fill', '#ff5555')
                    .call(drag(simulation));

                const label = svg.append('g')
                    .selectAll('text')
                    .data(nodes)
                    .join('text')
                    .text(d => d.label || d.id)
                    .attr('font-size', 10)
                    .attr('fill', '#fff');

                function ticked() {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);

                    label
                        .attr('x', d => d.x + 14)
                        .attr('y', d => d.y + 4);
                }

                function drag(simulation){
                    function dragstarted(event) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        event.subject.fx = event.subject.x;
                        event.subject.fy = event.subject.y;
                    }

                    function dragged(event) {
                        event.subject.fx = event.x;
                        event.subject.fy = event.y;
                    }

                    function dragended(event) {
                        if (!event.active) simulation.alphaTarget(0);
                        event.subject.fx = null;
                        event.subject.fy = null;
                    }

                    return d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended);
                }
            } catch (e) {
                container.innerHTML = '<div class="alert alert-warning">Unable to render wait-for graph: ' + e.message + '</div>';
            }
        }
        
        // Update anomaly timeline
        function updateAnomalyTimeline(anomalies) {
            // Update chart if we have data
            if (anomalyTimelineChart && anomalies) {
                const time = new Date().toLocaleTimeString();
                
                // Check if anomalies is an object with timeline property
                let anomalyList = anomalies;
                if (anomalies && typeof anomalies === 'object' && anomalies.hasOwnProperty('anomalies')) {
                    anomalyList = anomalies.anomalies;
                } else if (anomalies && typeof anomalies === 'object' && anomalies.hasOwnProperty('timeline')) {
                    anomalyList = anomalies.timeline;
                }
                
                if (Array.isArray(anomalyList) && anomalyList.length > 0) {
                    // Use the most recent anomaly score if available
                    const latestAnomaly = anomalyList[anomalyList.length - 1];
                    let anomalyScore = 0;
                    
                    if (latestAnomaly && latestAnomaly.hasOwnProperty('anomaly_score')) {
                        anomalyScore = Math.abs(parseFloat(latestAnomaly.anomaly_score) || 0);
                    } else if (latestAnomaly && latestAnomaly.hasOwnProperty('score')) {
                        anomalyScore = Math.abs(parseFloat(latestAnomaly.score) || 0);
                    } else if (latestAnomaly && latestAnomaly.hasOwnProperty('anomaly_value')) {
                        anomalyScore = Math.abs(parseFloat(latestAnomaly.anomaly_value) || 0);
                    } else if (latestAnomaly && latestAnomaly.hasOwnProperty('anomaly_score_normalized')) {
                        anomalyScore = Math.abs(parseFloat(latestAnomaly.anomaly_score_normalized) || 0);
                    } else if (latestAnomaly && latestAnomaly.hasOwnProperty('value')) {
                        anomalyScore = Math.abs(parseFloat(latestAnomaly.value) || 0);
                    } else {
                        // Fallback: use normalized value based on anomalies count
                        anomalyScore = Math.min(1.0, anomalyList.filter(a => a.is_anomaly || a.anomaly || (a.hasOwnProperty('severity') && a.severity !== 'info')).length / anomalyList.length);
                    }
                    
                    // Normalize the score to be between 0 and 1
                    anomalyScore = Math.min(1.0, Math.max(0, anomalyScore));
                    
                    // Add new data point
                    anomalyTimelineChart.data.labels.push(time);
                    if (anomalyTimelineChart.data.labels.length > 30) anomalyTimelineChart.data.labels.shift();
                    
                    anomalyTimelineChart.data.datasets[0].data.push(anomalyScore);
                    if (anomalyTimelineChart.data.datasets[0].data.length > 30) anomalyTimelineChart.data.datasets[0].data.shift();
                } else {
                    // Add 0 if no anomalies
                    anomalyTimelineChart.data.labels.push(time);
                    if (anomalyTimelineChart.data.labels.length > 30) anomalyTimelineChart.data.labels.shift();
                    
                    anomalyTimelineChart.data.datasets[0].data.push(0);
                    if (anomalyTimelineChart.data.datasets[0].data.length > 30) anomalyTimelineChart.data.datasets[0].data.shift();
                }
                
                anomalyTimelineChart.update();
            }
        }
        
        

        
        // Update real-time charts
        function updateRealtimeCharts() {
            // Get real data if available, otherwise simulate
            let cpu, memory, disk;
            
            if (currentPid && profile_data[currentPid] && profile_data[currentPid].length > 0) {
                // Use real data
                const latestMetric = profile_data[currentPid][profile_data[currentPid].length - 1];
                cpu = parseFloat(latestMetric.cpu_percent) || 0;
                memory = parseFloat(latestMetric.memory_percent) || 0;
                disk = (parseFloat(latestMetric.disk_read_mb) + parseFloat(latestMetric.disk_write_mb)) || 0;
            } else {
                // Simulate data for demonstration
                cpu = 20 + Math.sin(Date.now() / 5000) * 30 + Math.random() * 20;
                memory = 30 + Math.cos(Date.now() / 7000) * 25 + Math.random() * 15;
                disk = Math.random() * 30;
            }
            
            const time = new Date().toLocaleTimeString();
            
            // Update program resource chart
            if (programResourceChart) {
                const data = programResourceChart.data;
                data.labels.push(time);
                if (data.labels.length > 20) data.labels.shift();
                
                data.datasets[0].data.push(cpu);
                if (data.datasets[0].data.length > 20) data.datasets[0].data.shift();
                
                data.datasets[1].data.push(memory);
                if (data.datasets[1].data.length > 20) data.datasets[1].data.shift();
                
                data.datasets[2].data.push(disk);
                if (data.datasets[2].data.length > 20) data.datasets[2].data.shift();
                
                programResourceChart.update();
            }
            
            // The live metrics chart is now updated separately in the enhanced updateRealtimeCharts function
            // with process-specific metrics instead of system metrics
        }
        
        // Update live metrics chart with process-specific data
        function updateLiveMetricsChart() {
            if (!liveMetricsChart) return;
            
            // Get real data if available, otherwise simulate
            let cpu, memory, disk;
            
            if (currentPid && profile_data[currentPid] && profile_data[currentPid].length > 0) {
                // Use real data
                const latestMetric = profile_data[currentPid][profile_data[currentPid].length - 1];
                cpu = parseFloat(latestMetric.cpu_percent) || 0;
                memory = parseFloat(latestMetric.memory_percent) || 0;
                disk = (parseFloat(latestMetric.disk_read_mb) + parseFloat(latestMetric.disk_write_mb)) || 0;
            } else {
                // Simulate data for demonstration
                cpu = 20 + Math.sin(Date.now() / 5000) * 30 + Math.random() * 20;
                memory = 30 + Math.cos(Date.now() / 7000) * 25 + Math.random() * 15;
                disk = Math.random() * 30;
            }
            
            // Use selected process metrics if available, otherwise fall back to system metrics
            let procCpu = cpu;
            let procMemory = memory;
            let procDisk = disk; // disk was calculated earlier
            
            // Try to get metrics for the selected process
            if (selectedProcessData && selectedProcessData.cpu_percent !== undefined) {
                procCpu = selectedProcessData.cpu_percent;
                procMemory = selectedProcessData.memory_percent;
                procDisk = (selectedProcessData.memory_rss_mb || 0);
            } else if (currentPid && profile_data[currentPid] && profile_data[currentPid].length > 0) {
                // Use the latest metric from the current process
                const latestMetric = profile_data[currentPid][profile_data[currentPid].length - 1];
                procCpu = parseFloat(latestMetric.cpu_percent) || cpu;
                procMemory = parseFloat(latestMetric.memory_percent) || memory;
                procDisk = (parseFloat(latestMetric.memory_rss_mb) || parseFloat(latestMetric.memory_used_mb) || disk);
            }
            
            const time = new Date().toLocaleTimeString();
            const liveData = liveMetricsChart.data;
            liveData.labels.push(time);
            if (liveData.labels.length > 30) liveData.labels.shift();
            
            liveData.datasets[0].data.push(procCpu);
            if (liveData.datasets[0].data.length > 30) liveData.datasets[0].data.shift();
            
            liveData.datasets[1].data.push(procMemory);
            if (liveData.datasets[1].data.length > 30) liveData.datasets[1].data.shift();
            
            liveData.datasets[2].data.push(procDisk);
            if (liveData.datasets[2].data.length > 30) liveData.datasets[2].data.shift();
            
            liveMetricsChart.update();
        }
        
        // Initialize charts
        function initCharts() {
            // Program resource chart
            const resourceCtx = document.getElementById('programResourceChart').getContext('2d');
            programResourceChart = new Chart(resourceCtx, {
                type: 'line',
                data: {
                    labels: Array(10).fill(''),
                    datasets: [
                        {
                            label: 'CPU %',
                            data: Array(10).fill(0),
                            borderColor: '#64ffda',
                            backgroundColor: 'rgba(100, 255, 218, 0.1)',
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'Memory %',
                            data: Array(10).fill(0),
                            borderColor: '#bd93f9',
                            backgroundColor: 'rgba(189, 147, 249, 0.1)',
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'Disk I/O MB/s',
                            data: Array(10).fill(0),
                            borderColor: '#ffb86c',
                            backgroundColor: 'rgba(255, 184, 108, 0.1)',
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f8f8f2' }
                        }
                    },
                    scales: {
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#f8f8f2' },
                            min: 0
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#f8f8f2' }
                        }
                    }
                }
            });
            
            // Live metrics chart (execution tab)
            const liveCtx = document.getElementById('liveMetricsChart').getContext('2d');
            liveMetricsChart = new Chart(liveCtx, {
                type: 'line',
                data: {
                    labels: Array(30).fill(''),
                    datasets: [
                        {
                            label: 'CPU %',
                            data: Array(30).fill(0),
                            borderColor: '#64ffda',
                            tension: 0.3
                        },
                        {
                            label: 'Memory %',
                            data: Array(30).fill(0),
                            borderColor: '#bd93f9',
                            tension: 0.3
                        },
                        {
                            label: 'Disk (MB)',
                            data: Array(30).fill(0),
                            borderColor: '#ffb86c',
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f8f8f2' }
                        }
                    },
                    scales: {
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#f8f8f2' },
                            min: 0
                            // Note: We don't set max: 100 anymore since disk usage can be higher
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#f8f8f2' }
                        }
                    }
                }
            });
            
            // Phase distribution chart
            const phaseCtx = document.getElementById('phaseDistributionChart').getContext('2d');
            phaseDistributionChart = new Chart(phaseCtx, {
                type: 'doughnut',
                data: {
                    labels: ['CPU-bound', 'I/O-bound', 'Memory-bound', 'Mixed', 'Idle'],
                    datasets: [{
                        data: [30, 25, 15, 20, 10],
                        backgroundColor: [
                            '#64ffda',
                            '#bd93f9',
                            '#ffb86c',
                            '#ff79c6',
                            '#50fa7b'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f8f8f2' }
                        }
                    }
                }
            });
            
            // Anomaly timeline chart (intelligence tab)
            const anomalyCtx = document.getElementById('anomalyTimelineChart').getContext('2d');
            anomalyTimelineChart = new Chart(anomalyCtx, {
                type: 'line',
                data: {
                    labels: Array(30).fill(''),
                    datasets: [
                        {
                            label: 'Anomaly Score',
                            data: Array(30).fill(0),
                            borderColor: '#ff5555',
                            backgroundColor: 'rgba(255, 85, 85, 0.1)',
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#f8f8f2' }
                        }
                    },
                    scales: {
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#f8f8f2' },
                            min: 0,
                            max: 1
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#f8f8f2' }
                        }
                    }
                }
            });
        }
        
        // Alert action handlers
        function acknowledgeAlert(index) {
            console.log(`Acknowledging alert #${index}`);
            // In a real implementation, this would send a request to the backend
            alert(`Alert #${index + 1} acknowledged`);
        }
        
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
            
            // Set up periodic updates
            setInterval(() => {
                if (currentPid) {
                    updateDashboard();
                }
                // Update live metrics chart with process-specific data
                updateLiveMetricsChart();
            }, 2000); // Update every 2 seconds
            
            // Initial demo data
            setTimeout(() => {
                if (!currentPid) {
                    // Show demo data when no process is running
                    document.getElementById('prog-name').textContent = 'Demo Program';
                    document.getElementById('prog-pid').textContent = '--';
                    document.getElementById('prog-uptime').textContent = '--';

                    document.getElementById('current-phase').textContent = 'idle';
                    document.getElementById('active-anomalies').textContent = '0';
                    document.getElementById('deadlock-status').textContent = 'CLEAN';

                    
                    document.getElementById('sys-cpu').textContent = '15.2%';
                    document.getElementById('sys-mem').textContent = '48.7%';
                    document.getElementById('sys-disk-io').textContent = '5.3%';
                    document.getElementById('top-sys-consumers').textContent = 'System Idle, Chrome, VSCode';
                }
            }, 1000);
        });
    </script>
</body>
</html>